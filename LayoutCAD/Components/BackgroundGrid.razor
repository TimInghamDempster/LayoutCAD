<!-- The View for the backing grid, starts with the background rect-->
    <svg width="@ViewModel.ViewSize.X" height="@ViewModel.ViewSize.Y" @onmousewheel="OnMouseWheel" @onmousemove="OnMouseMove" @onmousedown="OnMouseDown">
        <!-- We have a coloured rect underneath the grid lines and labels-->
        <rect width="100%" height="100%" style="fill:rgb(128,128,255);stroke-width:0;stroke:rgb(0,0,0)" />
        <!-- Now draw the grid lines, both horizontal and vertical lines are in the same collection-->
        @foreach(var line in ViewModel.GridLines)
        {
            <!-- The line itself-->
            <line x1="@line.Start.ViewSpacePoint.X" x2="@line.End.ViewSpacePoint.X" y1="@line.Start.ViewSpacePoint.Y" y2="@line.End.ViewSpacePoint.Y" style="stroke-width:1;stroke:rgb(0,0,255)" />
            <!-- And a label telling us which line it is, this is a little tricky
                because blazor and svg both have a text tag that means different things
                so we have to wrap it in an svg tag to disambiguate.  We could also wrap
                it in a blazor text tag but that would break the dynamic content-->
            <svg> <text x="@line.TextPos.ViewSpacePoint.X" y="@line.TextPos.ViewSpacePoint.Y">@line.Text</text></svg>
        }
    </svg>
@code {
    [Parameter]
    public BackgroundGridVM ViewModel { set; private get; }

    private void OnMouseDown(MouseEventArgs args)
    {
        long leftButton = 1;
        if(args.Buttons == leftButton)
        {
            ViewModel.OnMouseDown(args.ScreenX, args.ScreenY);
        }
    }

    private void OnMouseWheel(WheelEventArgs args)
    {
        ViewModel.OnMouseWheel((float)args.DeltaY);
    }

    private void OnMouseMove(MouseEventArgs args)
    {
        ViewModel.OnMouseMove(args.Buttons, args.ScreenX, args.ScreenY);
    }
}
